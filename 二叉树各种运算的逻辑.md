## 求二叉树高度

1. 定义左子树高度为0，右子树高度为0
2. 如果本节点为空，返回0
3. 如果不为空，则进行递归:
   (1) 左子树高度为求高度(左子树节点)
   (2) 右子树高度为求高度(右子树节点)
   (3) 返回左右子树高度中较高的值

## 先序遍历

递归实现:

 1. 如果本节点不为空:

    (1) 输出本节点的值

    (2) 递归输出左子树节点

    (3) 递归输出右子树节点

非递归实现:

 1. 定义一个树节点指针空栈

 2. 如果根节点不为空，将根节点指针入栈

 3. 栈不为空(栈顶指针top!=-1)时进入循环(while循环):

    (1) 取栈顶元素，输出对应值，退栈

    (2) 如果右子树不为空，则将右子树节点指针入栈

    (3) 如果左子树不为空，则将左子树节点指针入栈

PS：因为在输出完本节点后需要先输出左子树节点后输出右子树节点，所以在入栈是需要先入栈右子树节点，再入栈左子树节点。

## 中序遍历

递归实现：

 1. 如果本节点不为空:

    (1) 递归输出左子树节点

    (2) 输出本节点值

    (3) 递归输出右子树节点

非递归实现：

 1. 定义一个树节点指针空栈

 2. 如果根节点不为空

    (1) 设定一个指针p，指向根节点

    (2) 当栈不为空或者指针p不为空进入循环(while循环)

     1. 循环入栈进入此节点的最左后代节点

     2. 如果栈不为空

        (1) 将栈顶元素退栈，输出对应值

        (2) 将指针p赋值为p的右子树节点指针

## 后续遍历

递归实现:

 1. 如果本届点不为空:

    (1) 递归输出左子树节点

    (2) 递归输出右子树节点

    (3) 输出本节点

非递归实现：

 1. 定义一个树节点指针空栈，定义一个flag标记节点的左孩子是否访问过

 2. 如果根节点不为空

    (1) 进入循环直到栈空(do while循环)

     1. 循环入栈进入此节点的最左后代节点

     2. 设置节点指针p为空，定义左孩子访问标记flag=1

     3. 当栈不为空且该节点左孩子已访时(top!=-1&&flag)进入循环

        (1) 取栈顶元素

        (2) 如果栈顶的右孩子指针等于p

        	1. p=栈顶元素
         	2. 输出栈顶元素对应值，退栈

        (3)否则，进入栈顶元素的右孩子节点，flag=0 退出循环